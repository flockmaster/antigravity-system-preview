# PRD: Codex Task Dispatcher (用户版)

> 版本: 2.0 | 日期: 2026-02-09 | 状态: 待确认

## 1. 项目概述

### 1.1 定位
构建一个 **三方协作的 AI 项目管理系统**，让开发工作像流水线一样自动运转：

| 角色 | 实体 | 职责 |
|------|------|------|
| **用户 (User)** | 您 | 提需求、确认 PRD、处理重大问题 |
| **项目经理 (PM)** | Antigravity | 分解需求、调度任务、回答问题、更新进度、**自主决策** |
| **工程师 (Worker)** | Codex | 执行原子任务、汇报结果、提出问题 |

### 1.2 核心理念

> **"您只需要说需求，然后去睡觉。醒来时，代码已经写好了。"**

- **最小打扰原则**：PM 能决定的事情，PM 直接决定。仅在重大或难以抉择的问题上才会打扰您。
- **智能跳过原则**：如果某个任务被阻塞（等待您回复但您不在），PM 会优先执行其他无关任务，而不是傻等。
- **上下文隔离原则**：每个 Worker 拥有全新的上下文窗口，彻底杜绝任务间的幻觉污染。

---

## 2. 核心功能

| 功能 | 描述 | 优势 |
|-----|------|------|
| **三方协作** | User → PM → Worker 的清晰职责链 | 模拟真实团队，可追溯 |
| **交互式调度** | PM 监控 Worker 进程，实时响应问题 | 不是 "Fire and Forget" |
| **自主决策** | PM 优先自行判断常见问题 | 减少打扰用户 |
| **智能跳过** | 阻塞任务不阻塞整体进度 | 您睡觉时工作仍继续 |
| **上下文隔离** | 每个任务由独立 Worker 执行 | 杜绝幻觉污染 |
| **单一真实源** | PRD 即进度表，实时更新 | 无需维护额外状态 |

---

## 3. 关键设计决策

| 决策点 | 选择 | 理由 |
|-------|------|-----|
| 调度模式 | **交互式** (非脚本) | PM 可介入、可回答问题、可跳过 |
| Worker 工具 | Codex CLI | 响应快，支持隔离执行 |
| 执行模式 | 串行（v2.0 可扩展并行） | 简化依赖管理 |
| 失败策略 | 智能重试 3 次 → 标记 BLOCKED | 平衡自动化与安全性 |
| 问题响应 | PM 优先回答 → 不确定则询问 User | 最小打扰原则 |
| 阻塞处理 | 跳过 → 执行其他任务 | 保持整体进度 |

---

## 4. 工作流程

```
┌──────────────────────────────────────────────────────────────┐
│                     Phase 1: 需求对齐                         │
├──────────────────────────────────────────────────────────────┤
│  [User] 提出需求                                              │
│     ↓                                                        │
│  [PM] 分解需求，生成 PRD (用户版 + 研发版)                     │
│     ↓                                                        │
│  [User] 确认 PRD → "Go"                                       │
└──────────────────────────────────────────────────────────────┘
                              |
                              ↓
┌──────────────────────────────────────────────────────────────┐
│                     Phase 2: 任务调度                         │
├──────────────────────────────────────────────────────────────┤
│  [PM] 读取 PRD → 识别第一个 PENDING 任务 (T-001)              │
│     ↓                                                        │
│  [PM] 启动 Codex Worker (后台进程，全新上下文)                 │
│     ↓                                                        │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Worker 执行中 (PM 持续监控)                  │ │
│  │                                                         │ │
│  │  [Worker] 编写代码、运行测试...                          │ │
│  │  [Worker] 遇到问题 → 输出疑问                            │ │
│  │     ↓                                                   │ │
│  │  [PM] 检测到问题 → 判断:                                 │ │
│  │     ├─ 我能回答 → 直接回复 Worker                        │ │
│  │     └─ 我不确定 → 询问 User (或标记 BLOCKED 跳过)         │ │
│  │     ↓                                                   │ │
│  │  [Worker] 收到回复 → 继续执行                            │ │
│  └─────────────────────────────────────────────────────────┘ │
│     ↓                                                        │
│  [Worker] 任务完成 → 汇报结果                                 │
│     ↓                                                        │
│  [PM] 更新 PRD 状态 (T-001 → ✅ DONE)                         │
│     ↓                                                        │
│  还有任务? ─Yes─→ 回到 "识别下一个任务"                       │
│     │                                                        │
│     No                                                       │
│     ↓                                                        │
│  🎉 所有任务完成                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## 5. PM ↔ Worker 通信机制

### 5.1 架构概览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            PM (Antigravity)                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                  │
│  │ 任务调度器   │    │ 输出监控器   │    │  问题处理器  │                  │
│  │ (Scheduler) │    │ (Monitor)   │    │  (Handler)  │                  │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘                  │
│         │                  │                  │                         │
└─────────┼──────────────────┼──────────────────┼─────────────────────────┘
          │                  │                  │
          │ codex exec       │ 轮询 stdout      │ stdin 或 重启
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Worker (Codex CLI)                               │
│                                                                          │
│   [全新上下文] → 读取任务 Prompt → 执行 → 输出结果                          │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.2 启动 Worker

PM 通过 Codex CLI 启动独立 Worker：

```bash
codex exec --prompt "任务描述..." --approval-mode full-auto
```

- `--approval-mode full-auto`: Worker 自动执行，无需人工批准
- 每次启动都是**全新上下文**，无历史污染

### 5.3 监控 Worker 输出

PM 实时读取 Worker 的 stdout，识别结构化标签：

| 标签 | 含义 | PM 响应 |
|-----|------|--------|
| `[PROGRESS]` | 进度更新 | 记录，更新可视化 |
| `[QUESTION]` | Worker 有问题 | 判断后回复或标记 BLOCKED |
| `[DONE]` | 任务完成 | 更新 PRD 状态，调度下一个 |
| `[ERROR]` | 执行失败 | 分析原因，决定重试或 BLOCKED |

### 5.4 向 Worker 发送回复

**方案 A (首选) - 重启注入**：
- 如果 Worker 有问题且 PM 能回答，PM 终止当前 Worker
- 在原始 Prompt 中追加问题答案，重新启动 Worker
- Worker 在新上下文中继续执行

**方案 B (备用) - stdin 流式输入**：
- 如果 Codex CLI 支持运行时 stdin，PM 直接写入回复
- 需技术预研验证可行性

### 5.5 超时策略

| 任务类型 | 超时时间 | 处理方式 |
|---------|---------|---------|
| 代码修改 | 10 分钟 | 超时后 BLOCKED |
| 测试执行 | 15 分钟 | 超时后 BLOCKED |
| 构建任务 | 20 分钟 | 超时后 BLOCKED |

**注**: 超时后 PM 记录最后输出，供 User 分析。

---

## 6. 任务状态机

### 6.1 状态定义

```
                    ┌─────────────────────────────────────────┐
                    │                                         │
                    ▼                                         │
┌─────────┐    ┌─────────────┐    ┌─────────┐           ┌─────┴───┐
│ PENDING │───▶│ IN_PROGRESS │───▶│  DONE   │           │  RETRY  │
└─────────┘    └─────────────┘    └─────────┘           └─────────┘
     │              │                                         ▲
     │              │ 失败/问题                                │
     │              ▼                                         │
     │         ┌─────────┐      User 回复后                   │
     │         │ BLOCKED │─────────────────────────────────────┘
     │         └─────────┘
     │              │
     │              │ 3 次重试失败
     │              ▼
     │         ┌─────────┐
     │         │ FAILED  │
     │         └─────────┘
     │
     │ 依赖未满足
     ▼
┌─────────┐
│ SKIPPED │ (临时跳过，待依赖完成后恢复)
└─────────┘
```

### 6.2 状态说明

| 状态 | 图标 | 说明 |
|-----|------|-----|
| PENDING | ⏳ | 等待执行 |
| IN_PROGRESS | 🔄 | 正在执行中 |
| DONE | ✅ | 已完成 |
| BLOCKED | 🚫 | 需要 User 介入 |
| RETRY | 🔁 | 等待重试 (自动) |
| FAILED | ❌ | 失败 (需人工处理) |
| SKIPPED | ⏭️ | 临时跳过 |

### 6.3 状态流转规则

| 当前状态 | 触发条件 | 目标状态 |
|---------|---------|---------|
| PENDING | PM 开始调度 | IN_PROGRESS |
| PENDING | 依赖任务 BLOCKED | SKIPPED |
| IN_PROGRESS | Worker 完成 | DONE |
| IN_PROGRESS | Worker 提问 (PM 能答) | IN_PROGRESS (继续) |
| IN_PROGRESS | Worker 提问 (PM 不确定) | BLOCKED |
| IN_PROGRESS | Worker 失败 (可重试) | RETRY |
| IN_PROGRESS | 超时 | BLOCKED |
| BLOCKED | User 回复 | RETRY |
| RETRY | 重试成功 | DONE |
| RETRY | 重试 3 次仍失败 | FAILED |
| SKIPPED | 依赖任务完成 | PENDING |

---

## 7. Worker 输出协议

### 7.1 结构化输出格式

Worker 在执行过程中应使用以下标签输出：

```
[PROGRESS] 25% - 正在分析代码结构...
[PROGRESS] 50% - 正在编写实现代码...
[QUESTION] API 的认证方式是 Bearer Token 还是 API Key？
[PROGRESS] 75% - 正在编写测试代码...
[DONE] 任务完成，提交: abc1234
```

### 7.2 标签详细定义

#### `[PROGRESS]` - 进度报告
```
[PROGRESS] <百分比>% - <当前操作描述>
```

#### `[QUESTION]` - 提问
```
[QUESTION] <问题描述>
[CONTEXT] <可选的上下文信息>
[OPTIONS] <可选的选项列表>
```

示例：
```
[QUESTION] 用户认证应该使用哪种方式？
[CONTEXT] 发现项目中同时存在 Firebase Auth 和自建认证
[OPTIONS] A) Firebase Auth  B) 自建认证  C) 两者兼容
```

#### `[DONE]` - 完成报告
```
[DONE] <完成摘要>
[COMMIT] <Git commit hash>
[FILES] <修改的文件列表>
```

#### `[ERROR]` - 错误报告
```
[ERROR] <错误类型>: <错误描述>
[STACK] <可选的堆栈信息>
[SUGGESTION] <可选的建议>
```

### 7.3 PM 输出解析流程

```
While Worker 运行:
    line = 读取 Worker stdout
    
    If line 匹配 [QUESTION]:
        question = 解析问题内容
        If PM 能回答(question):
            重启 Worker (追加答案)
        Else:
            标记 BLOCKED
            跳过执行其他任务
    
    If line 匹配 [DONE]:
        更新 PRD 状态 → DONE
        调度下一个任务
    
    If line 匹配 [ERROR]:
        If 可重试:
            标记 RETRY
        Else:
            标记 BLOCKED
```

---

## 8. PM 自主决策范围

### 8.1 PM 可自行决定的问题

| 问题类型 | 示例 | PM 决策 |
|---------|------|--------|
| 技术选型 (小) | "用 async/await 还是 .then()?" | 选择更现代的方案 |
| 命名规范 | "变量名用 camelCase 还是 snake_case?" | 遵循项目现有规范 |
| 实现细节 | "用 Map 还是 List?" | 根据性能需求选择 |
| 缺失依赖 | "找不到 X 模块" | 检查并提供正确路径 |

### 8.2 PM 必须询问 User 的问题

| 问题类型 | 示例 | 处理方式 |
|---------|------|----------|
| 需求歧义 | "用户说的 'X' 是什么意思?" | 标记 BLOCKED，询问 User |
| 架构决策 | "需要新增数据库表吗?" | 询问 User |
| 风险操作 | "需要删除现有数据吗?" | 必须 User 确认 |
| 超出范围 | "这个功能不在 PRD 中" | 询问 User 是否扩展范围 |

---

## 9. 阻塞任务处理策略

当任务因等待 User 回复而阻塞时：

1. **标记状态**: 将任务标记为 `🚫 BLOCKED (等待 User)`
2. **记录问题**: 在 PRD 或 `active_context.md` 中记录阻塞原因
3. **跳过执行**: 查找下一个**无依赖关系**的 PENDING 任务
4. **继续调度**: 执行其他任务，直到:
   - 所有非阻塞任务完成
   - 或 User 回复后恢复阻塞任务

```
任务依赖图:
  T-001 (DONE)
    ├── T-002 (BLOCKED - 等待 User)
    │     └── T-004 (PENDING - 被 T-002 阻塞)
    └── T-003 (PENDING - 无依赖) ← PM 跳到这里执行
```

---

## 10. 不做什么 (Out of Scope v2.0)

- ❌ 不支持并行执行（v2.0，未来可扩展）
- ❌ 不支持跨项目任务派发
- ❌ 不支持 Web UI 监控面板

---

## 11. 风险与挑战

### 11.1 运行时风险

| 风险 | 影响 | 缓解措施 |
|-----|------|---------|
| ⚠️ Worker 卡死 | 任务无限等待 | PM 设置超时（15分钟），强制终止 |
| ⚠️ PM 误判问题 | 回答错误导致代码问题 | PM 对不确定的问题标记 BLOCKED |
| ⚠️ 阻塞任务过多 | 整体进度停滞 | 通知 User 批量处理阻塞问题 |
| ⚠️ Git 冲突 | 代码丢失 | 每个任务完成后自动 commit |

### 11.2 技术预研依赖 (阻塞风险)

> ⚠️ **注意**: 以下技术点需在正式开发前验证，若验证失败可能导致方案调整。

| 预研项 | 验证内容 | 影响范围 | 备选方案 |
|-------|---------|---------|---------|
| 🔬 **Codex CLI 交互能力** | 运行中的 Worker 能否接收 stdin 输入？ | 第 5.4 节 "向 Worker 发送回复" | 若不支持 → 使用 "重启注入" 方案 |
| 🔬 **结构化输出可行性** | Worker 能否被 Prompt 约束为结构化输出？ | 第 7 节 "Worker 输出协议" | 若不可靠 → PM 使用模糊匹配解析 |

**预研时间预估**: 1-2 小时

**预研完成标准**:
1. 提供技术验证结论文档
2. 若方案可行，继续正式开发
3. 若方案不可行，启用备选方案并更新 PRD

---

## 12. 成功指标

| 指标 | 目标 | 说明 |
|------|------|------|
| **自动化率** | ≥ 80% | 无需 User 介入即可完成的任务比例 |
| **PM 自主决策率** | ≥ 70% | Worker 问题由 PM 直接回答的比例 |
| **阻塞恢复时间** | < 5 分钟 | User 回复后恢复执行的时间 |
| **整体完成时间** | 10 任务 / 30 分钟 | 端到端效率 |

---

**请确认以上内容，说 "Go" 进入技术评审**

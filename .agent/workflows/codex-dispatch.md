---
description: 自动派发 Codex 任务流水线
---

# Codex Task Dispatcher v3.0 (Agent Native)

> **核心理念**: 利用大模型的自然语言理解能力，直接从 PRD 中识别和派发任务。
> **无需脚本解析**，完全由 Agent 主导调度。

---

## 触发方式

| 用户说... | Agent 行为 |
|----------|-----------|
| "执行 PRD" / "开始调度" | 读取 PRD，自动识别下一个任务 |
| "做 T-001" / "执行 001" | 直接跳到指定任务执行 |
| "跳过 T-002" | 将 T-002 标记为 SKIPPED |
| "继续" | 从上次中断处恢复 |

---

## 调度循环 (核心流程)

### Step 1: 定位 PRD 📄

如果用户没有指定 PRD 路径，自动查找 `docs/prd/*-dev.md` 中最新修改的文件。

### Step 2: 读取并理解 PRD 🧠

使用 `view_file` 读取整个 PRD 文件。

**Agent 思考要点**：
1. 找到任务列表（通常是表格形式，但不强制）
2. 识别每个任务的 ID、名称、状态、依赖关系
3. 不依赖固定格式 —— 用自然语言理解任务结构

### Step 3: 选择下一个任务 🎯

**判断逻辑**（Agent 自行推理）：
1. 找出所有状态为 **PENDING** (⏳) 的任务
2. 过滤出依赖已全部 **DONE** (✅) 的任务
3. 选择其中编号最小的作为下一个

**终止条件**：
- 所有任务 DONE → 输出 "🎉 全部完成！" → 结束
- 有 PENDING 但依赖未满足 → 输出阻塞原因 → 等待用户
- 存在 BLOCKED 任务 → 询问用户如何处理

### Step 4: 构造 Worker Prompt 📝

根据选中的任务，构造给 Codex Worker 的完整 Prompt：

```
你是一个专注的开发者，负责完成以下任务。

## 任务信息
- **ID**: {任务 ID}
- **名称**: {任务名称}  
- **描述**: {任务描述}
- **工作目录**: {当前项目路径}

## 执行规范
1. 仅完成本任务描述的内容，不做超出范围的事
2. 完成后说: "任务 {ID} 完成" 
3. 如果遇到需要澄清的问题，明确说出你的疑问
4. 如果遇到致命阻塞无法继续，说明原因

## 上下文 (如有之前的补充信息)
{此处追加 PM 传递的额外信息}
```

### Step 5: 启动 Codex Worker 🚀

// turbo
```bash
codex exec --full-auto --json "{Prompt}"
```

**参数说明**：
- `--full-auto`: 全自动模式，无人工确认
- `--json`: 输出 JSONL 事件流，便于监控

### Step 6: 实时监控 👀

Agent 读取 Worker 的 stdout，解析 JSONL 事件：

| 事件/模式 | Agent 响应 |
|----------|-----------|
| `agent_message` 包含疑问句 | 尝试回答 → 或标记 BLOCKED |
| `tool_call` / `tool_result` | 记录进度 |
| `error` 事件 | 判断是否可重试 |
| `session_end` 且成功 | 更新 PRD 状态为 DONE |
| 超时 (15分钟无输出) | 终止进程，标记 BLOCKED |

### Step 7: 干预决策 🧑‍⚖️ (如需)

如果 Worker 提出问题，Agent 作为 PM 自主判断：

| 问题类型 | Agent 决策 |
|---------|-----------|
| 技术选型 (小) | 自行决定，采用更现代的方案 |
| 命名规范 | 遵循项目现有规范 |
| 风险操作 (删除数据等) | 标记 BLOCKED，必须询问用户 |
| 需求歧义 | 标记 BLOCKED，询问用户 |

**回答问题的方式**（重启注入机制）：
1. 终止当前 Worker 进程
2. 将答案追加到原 Prompt 的"上下文"部分
3. 重新启动 Worker

### Step 8: 更新 PRD 状态 ✍️

任务完成后，使用 `replace_file_content` 更新 PRD 中对应行的状态：

- PENDING (⏳) → DONE (✅) 
- 更新时保留表格格式和其他列内容

### Step 9: 循环继续 🔄

回到 **Step 3**，继续选择下一个任务，直到满足终止条件。

---

## 特殊情况处理

### 🚫 任务阻塞
1. 记录阻塞原因到 `active_context.md`
2. 查找其他无依赖的 PENDING 任务
3. 如果有 → 跳过阻塞任务，执行其他任务
4. 如果没有 → 通知用户所有待解决的阻塞问题

### ❌ Worker 失败
1. 第 1-2 次失败: 自动重试
2. 第 3 次失败: 标记 FAILED，询问用户

### ⏰ 超时处理
- 代码修改任务: 10 分钟超时
- 测试/构建任务: 15-20 分钟超时
- 超时后强制终止，标记 BLOCKED

---

## Git 集成

每个任务完成后自动执行：

// turbo
```bash
git add -A && git commit -m "feat(T-{ID}): {任务名称}"
```

---

## 使用示例

### 示例 1: 执行整个 PRD
```
用户: 执行 docs/prd/feature-x-dev.md
Agent: [读取 PRD] 
       找到 10 个任务，其中 T-001 已完成。
       下一个任务: T-002
       正在启动 Codex Worker...
       [监控输出]
       T-002 完成！更新 PRD。
       下一个: T-003...
       [循环]
       🎉 全部完成！共执行 9 个任务。
```

### 示例 2: 指定任务
```
用户: 做 003
Agent: 定位到 T-003: "实现交互式监控"
       依赖 T-002 状态: ✅ DONE (满足)
       启动执行...
```

### 示例 3: 处理阻塞
```
Agent: T-004 执行中...
       Worker 提问: "日志应该存放在哪个目录？"
       这是技术细节，我可以自行决定。
       回答: "使用 .agent/logs/ 目录"
       [重启 Worker 并注入答案]
       T-004 继续执行...
```

---

## 与传统方式的对比

| 维度 | v2.0 (脚本驱动) | v3.0 (Agent 原生) |
|-----|----------------|------------------|
| PRD 解析 | parser.py 硬编码 | Agent 自然语言理解 |
| PRD 格式要求 | 严格表格格式 | 灵活，任意结构 |
| 调度逻辑 | dispatch_loop.sh | Agent 思考判断 |
| 可扩展性 | 需改代码 | 直接改 Prompt |
| 透明度 | 脚本黑盒 | Agent 每步可见 |
